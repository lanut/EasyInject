using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace Lanut.EasyInject;

/// <summary>
/// An incremental source generator that automatically generates dependency injection service registration code.
/// </summary>
/// <remarks>
/// <para>
/// This generator scans all classes marked with the <c>[Injectable]</c> attribute and automatically generates
/// an extension method to register these services with <see cref="Microsoft.Extensions.DependencyInjection.IServiceCollection"/>.
/// </para>
/// <para>
/// The generated extension method is named <c>Add{AssemblyName}Services</c>, where dots in the assembly name are removed.
/// </para>
/// <example>
/// Usage example:
/// <code>
/// [Injectable(ServiceLifetime.Scoped)]
/// public class MyService : IMyService { }
/// 
/// // The generated code can be used like this:
/// services.AddMyProjectServices();
/// </code>
/// </example>
/// </remarks>
[Generator]
public class DiAutoGenerators : IIncrementalGenerator
{
    /// <summary>
    /// The fully qualified name of the Injectable attribute, used to identify marked classes at compile time.
    /// </summary>
    private const string attributeFullName = "Lanut.EasyInject.InjectableAttribute";

    /// <summary>
    /// The source code definition of the Injectable attribute.
    /// This code is injected into the target project during the compilation initialization phase.
    /// </summary>
    /// <remarks>
    /// The attribute supports two parameters:
    /// <list type="bullet">
    /// <item><description>lifetime: The service lifetime (Singleton, Scoped, Transient)</description></item>
    /// <item><description>serviceType: Optional service type; if not specified, the first interface implemented by the class is used</description></item>
    /// </list>
    /// </remarks>
    private const string attributeSourceCode = """
                                               // <auto-generated/>
                                               #nullable enable
                                               namespace Lanut.EasyInject
                                               {
                                                   /// <summary>
                                                   /// Marks a class for automatic dependency injection registration.
                                                   /// </summary>
                                                   /// <remarks>
                                                   /// If the class implements multiple interfaces and no specific service type is provided,
                                                   /// only the first interface will be registered as the service type.
                                                   /// </remarks>
                                                   [System.AttributeUsage(System.AttributeTargets.Class, Inherited = false, AllowMultiple = true)]
                                                   internal sealed class InjectableAttribute : System.Attribute
                                                   {
                                                       /// <summary>
                                                       /// Initializes a new instance of the <see cref="InjectableAttribute"/> class.
                                                       /// </summary>
                                                       /// <param name="lifetime">The service lifetime.</param>
                                                       /// <param name="serviceType">The service type to register. If null, the first interface implemented by the class will be used.</param>
                                                       public InjectableAttribute(Microsoft.Extensions.DependencyInjection.ServiceLifetime lifetime, System.Type? serviceType = null) 
                                                       {
                                                           Lifetime = lifetime;
                                                           ServiceType = serviceType;
                                                       }

                                                       /// <summary>
                                                       /// Gets the service lifetime.
                                                       /// </summary>
                                                       public Microsoft.Extensions.DependencyInjection.ServiceLifetime Lifetime { get; }

                                                       /// <summary>
                                                       /// Gets the service type.
                                                       /// </summary>
                                                       public System.Type? ServiceType { get; }
                                                   }
                                               }

                                               """;

    /// <summary>
    /// The footer portion of the generated extension method code.
    /// Contains the return statement and closing braces for the class and namespace.
    /// </summary>
    private const string extensionFooter = """
                                                       return services;
                                                   }
                                               }
                                           }
                                           """;

    /// <summary>
    /// Initializes the incremental source generator.
    /// </summary>
    /// <param name="context">The incremental generator initialization context that provides methods for registering the generation pipeline.</param>
    /// <remarks>
    /// This method sets up an incremental generation pipeline with the following steps:
    /// <list type="number">
    /// <item><description>Register the Injectable attribute source code into the compilation</description></item>
    /// <item><description>Find all classes marked with the Injectable attribute</description></item>
    /// <item><description>Extract service registration information</description></item>
    /// <item><description>Generate the service registration extension method</description></item>
    /// </list>
    /// </remarks>
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Step 1: Add the Injectable attribute source code during post-initialization
        // This ensures the attribute definition exists before any user code attempts to use it
        context.RegisterPostInitializationOutput(ctx => ctx.AddSource(
            "InjectableAttribute.g.cs",
            SourceText.From(attributeSourceCode, System.Text.Encoding.UTF8)
        ));

        // Step 2: Create an incremental value provider to find all classes marked with the Injectable attribute
        // ForAttributeWithMetadataName is an efficient method that only re-executes when attribute-related code changes
        var registrations = context.SyntaxProvider
            .ForAttributeWithMetadataName(
                attributeFullName,
                // Predicate: only process class declaration syntax nodes
                predicate: static (node, _) => node is ClassDeclarationSyntax,
                // Transform: extract service registration information from the syntax context
                transform: static (ctx, _) => ExtractRegistration(ctx))
            .SelectMany(static (x, _) => x);

        // Step 3: Get the assembly name, used to generate the extension method name
        var assemblyName = context.CompilationProvider
            .Select(static (c, _) => c.AssemblyName ?? "Project");

        // Step 4: Register the source output
        // Collect all registration info into an array and combine with the assembly name
        // The Execute method is called when any input changes
        context.RegisterSourceOutput(
            registrations.Collect().Combine(assemblyName),
            static (ctx, source) => Execute(ctx, source.Left, source.Right));
    }

    /// <summary>
    /// Extracts service registration information from the generator attribute syntax context.
    /// </summary>
    /// <param name="context">The generator context containing target symbol and attribute information.</param>
    /// <returns>
    /// A <see cref="ServiceRegistration"/> if extraction succeeds;
    /// <c>null</c> if the target is not a valid class symbol or the attribute arguments are invalid.
    /// </returns>
    /// <remarks>
    /// This method performs the following operations:
    /// <list type="bullet">
    /// <item><description>Validates that the target symbol is a named type</description></item>
    /// <item><description>Parses the Injectable attribute's constructor arguments</description></item>
    /// <item><description>Determines the service type (explicitly specified or first interface)</description></item>
    /// <item><description>Handles special cases for generic types</description></item>
    /// </list>
    /// </remarks>
    private static IEnumerable<ServiceRegistration> ExtractRegistration(GeneratorAttributeSyntaxContext context)
    {
        // Validate that the target symbol is a named type symbol (class, struct, interface, etc.)
        if (context.TargetSymbol is not INamedTypeSymbol classSymbol) yield break;
        
        // Find all Injectable attributes on the target symbol
        var attributes = context.Attributes.Where(a =>
            a.AttributeClass?.ToDisplayString() == attributeFullName);
        
        // Process each Injectable attribute separately
        foreach (var attribute in attributes)
        {
            // Parse the lifetime parameter
            // ServiceLifetime enum values: 0 = Singleton, 1 = Scoped, 2 = Transient
            // Default to Scoped (1) if parsing fails
            var args = attribute.ConstructorArguments;
            var lifetime = args.Length > 0 && args[0].Value is int lt ? lt : 1;
            
            // Parse the explicitly specified service type (second optional parameter)
            // If the serviceType parameter is specified, use it; otherwise null
            var explicitServiceType = args.Length > 1 && args[1].Value is INamedTypeSymbol st
                ? GetTypeName(st, classSymbol.IsGenericType)
                : null;
            
            // Build and yield the service registration information
            yield return new ServiceRegistration(
                FullyQualifiedClassName: GetTypeName(classSymbol, classSymbol.IsGenericType),
                FullyQualifiedServiceType: explicitServiceType,
                FirstInterfaceType: explicitServiceType is null && classSymbol.Interfaces.Length > 0
                    ? GetTypeName(classSymbol.Interfaces[0], classSymbol.IsGenericType)
                    : null,
                Lifetime: lifetime,
                IsGeneric: classSymbol.IsGenericType);
        }
    }

    /// <summary>
    /// Gets the fully qualified name string for a type symbol.
    /// </summary>
    /// <param name="symbol">The type symbol to get the name for.</param>
    /// <param name="useUnbound">
    /// If <c>true</c> and the type is generic, returns a typeof expression for the unbound generic type;
    /// otherwise returns the fully qualified type name.
    /// </param>
    /// <returns>
    /// A string representation of the type. For generic types, returns <c>typeof(Namespace.Type&lt;,&gt;)</c> format;
    /// for non-generic types, returns <c>global::Namespace.Type</c> format.
    /// </returns>
    /// <remarks>
    /// Generic types require special handling because when registering services at runtime,
    /// <c>typeof()</c> expressions must be used instead of generic type parameter syntax.
    /// </remarks>
    /// <example>
    /// <code>
    /// // Non-generic type
    /// GetTypeName(myClassSymbol, false) // Returns "global::MyNamespace.MyClass"
    /// 
    /// // Generic type
    /// GetTypeName(myGenericSymbol, true) // Returns "typeof(global::MyNamespace.MyClass&lt;,&gt;)"
    /// </code>
    /// </example>
    private static string GetTypeName(INamedTypeSymbol symbol, bool useUnbound)
    {
        // For generic types, if unbound form is needed, construct the unbound generic type
        // Example: List<T> -> List<>
        var targetSymbol = useUnbound && symbol.IsGenericType
            ? symbol.ConstructUnboundGenericType()
            : symbol;

        // Get the type name using fully qualified format (includes global:: prefix)
        var name = targetSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);

        // For unbound generic types, wrap in typeof()
        return useUnbound ? $"typeof({name})" : name;
    }

    /// <summary>
    /// Executes source code generation to create the service registration extension method.
    /// </summary>
    /// <param name="context">The source production context used to output generated code.</param>
    /// <param name="registrations">The collection of all service registration information.</param>
    /// <param name="assemblyName">The current assembly name, used to generate the extension method name.</param>
    /// <remarks>
    /// <para>
    /// This method generates a static extension method class <c>ServiceCollectionExtensions</c>
    /// containing an extension method named <c>Add{AssemblyName}Services</c>.
    /// </para>
    /// <para>
    /// The generated code calls the appropriate registration method based on service lifetime:
    /// <list type="bullet">
    /// <item><description>Singleton (0): <c>AddSingleton</c></description></item>
    /// <item><description>Scoped (1): <c>AddScoped</c></description></item>
    /// <item><description>Transient (2): <c>AddTransient</c></description></item>
    /// </list>
    /// </para>
    /// <para>
    /// Generic services use non-generic overloads (passing Type parameters),
    /// while non-generic services use generic overloads (using type parameters).
    /// </para>
    /// </remarks>
    private static void Execute(
        SourceProductionContext context,
        ImmutableArray<ServiceRegistration> registrations,
        string assemblyName)
    {
        // If there are no registrations, don't generate any code
        if (registrations.IsDefaultOrEmpty) return;

        // Generate the extension method name by removing dots from the assembly name
        // Example: MyOrg.MyProject -> AddMyOrgMyProjectServices
        var methodName = $"Add{assemblyName.Replace(".", "")}Services";

        // Pre-allocate StringBuilder capacity for better performance
        // Base capacity of 512 bytes + approximately 100 bytes per registration
        var sb = new StringBuilder(512 + registrations.Length * 100);

        // Generate the file header: namespace, using statements, class declaration, and method signature
        sb.Append($$"""
                    // <auto-generated/>
                    #nullable enable
                    using Microsoft.Extensions.DependencyInjection;

                    namespace Lanut.EasyInject
                    {
                        public static partial class ServiceCollectionExtensions
                        {
                            public static IServiceCollection {{methodName}}(this IServiceCollection services)
                            {

                    """);

        // Iterate through all service registrations and generate corresponding registration code
        foreach (ref readonly var reg in registrations.AsSpan())
        {
            // Select the appropriate registration method based on lifetime value
            // ServiceLifetime: 0 = Singleton, 1 = Scoped, 2 = Transient
            var method = reg.Lifetime switch
            {
                0 => "AddSingleton",
                2 => "AddTransient",
                _ => "AddScoped"  // Default to Scoped
            };

            // Determine service type: prefer explicitly specified type, then fall back to first interface
            var serviceType = reg.FullyQualifiedServiceType
                ?? reg.FirstInterfaceType;

            // Start building the registration statement
            sb.Append("            services.");
            sb.Append(method);

            if (serviceType != null)
            {
                // Has a service type (interface or explicitly specified type)
                if (reg.IsGeneric)
                {
                    // Generic types use non-generic overload, passing Type parameters
                    // Example: services.AddScoped(typeof(IRepository<>), typeof(Repository<>));
                    sb.Append($"({serviceType}, {reg.FullyQualifiedClassName})");
                }
                else
                {
                    // Non-generic types use generic overload
                    // Example: services.AddScoped<IMyService, MyService>();
                    sb.Append($"<{serviceType}, {reg.FullyQualifiedClassName}>()");
                }
            }
            else
            {
                // No service type, register only the implementation type itself
                if (reg.IsGeneric)
                {
                    // Generic types use non-generic overload
                    // Example: services.AddScoped(typeof(MyService<>));
                    sb.Append($"({reg.FullyQualifiedClassName})");
                }
                else
                {
                    // Non-generic types use generic overload
                    // Example: services.AddScoped<MyService>();
                    sb.Append($"<{reg.FullyQualifiedClassName}>()");
                }
            }

            // Add the statement-ending semicolon and newline
            sb.AppendLine(";");
        }

        // Add the method and class closing portion
        sb.Append(extensionFooter);

        // Add the generated code to the compilation output
        context.AddSource("ServiceCollectionExtensions.g.cs",
            SourceText.From(sb.ToString(), Encoding.UTF8));
    }

    /// <summary>
    /// Represents all necessary information for a service registration.
    /// </summary>
    /// <param name="FullyQualifiedClassName">The fully qualified name of the implementation class.</param>
    /// <param name="FullyQualifiedServiceType">The fully qualified name of the explicitly specified service type, or <c>null</c> if not specified.</param>
    /// <param name="FirstInterfaceType">The fully qualified name of the first interface implemented by the class, or <c>null</c> if no interfaces are implemented.</param>
    /// <param name="Lifetime">The service lifetime: 0 = Singleton, 1 = Scoped, 2 = Transient.</param>
    /// <param name="IsGeneric">Indicates whether the implementation class is a generic type.</param>
    /// <remarks>
    /// Uses <c>readonly record struct</c> for optimal performance:
    /// <list type="bullet">
    /// <item><description>Value type avoids heap allocation</description></item>
    /// <item><description>readonly ensures immutability</description></item>
    /// <item><description>record provides value equality semantics</description></item>
    /// </list>
    /// </remarks>
    private readonly record struct ServiceRegistration(
        string FullyQualifiedClassName,
        string? FullyQualifiedServiceType,
        string? FirstInterfaceType,
        int Lifetime,
        bool IsGeneric);
}
